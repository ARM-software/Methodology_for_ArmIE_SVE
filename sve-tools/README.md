# SVE Post-processing tools

Collection of SVE post-processing tools.

These tools parse ArmIE generated trace files and generate statistics and metrics utilised in the methodology.
They were tested with traces generated by ArmIE 19.2.

## Building the tools

Edit the ``Makefile`` and make sure ``CXX`` points to a working C++ compiler. Then, just type ``make`` in the current folder, everything should be compiled.

The current building process has been tested with ``armclang++`` 19.3 in a Linux environment.

## Memtrace Merger

The memory trace client distributed with ArmIE (<=19.2) generates two separate trace files, one for SVE memory accesses and another for non-SVE accesses.
The tools provided in this package require a single and complete (merged) trace file. Hence a memory trace merger.

This tool accepts two memory traces as positional parameters. The usage is as follows:

```bash
merge [OPTIONS] aarch64_memtrace_file sve_memtrace_file
Options:
        -o <outputFile>  Redirect output to <outputFile> (default: stdout)
        -h               Print this help
```

**NOTE:** The options MUST go before the memory trace files arguments.

Here is an example of how to build and execute the tool:

```bash
$ make merger
make -C memtrace_merger
make[1]: Entering directory `/methodology_for_ArmIE_SVE/sve-tools/memtrace_merger'
armclang++ -O3 -mcpu=native -pthread -Iinclude/ -c -o src/merge.o src/merge.cpp
armclang++ -O3 -mcpu=native -pthread -Iinclude/ -c -o src/Options.o src/Options.cpp
armclang++ -O3 -mcpu=native -pthread -o bin/merge src/merge.o src/Options.o
make[1]: Leaving directory `/methodology_for_ArmIE_SVE/sve-tools/memtrace_merger'

$ ./memtrace_merger/bin/merge -o merged-memtrace.example.log memtrace.example.log sve-memtrace.example.log
```

## Memtrace analyzer

This tool accepts one complete memory trace (previous merged) and reports the number and types of memory accesses. The usage is as follows:

```bash
analyze [OPTIONS] merged_memtrace_file
Options:
        -t <threads>     Specify how many threads to use for parallel processing (default: 1)
        -v <VL>          Vector length (required)
        -o <outputFile>  Redirect output to <outputFile> (default: stdout)
        -h               Print this help
```
Note that a higher number of threads will increase the performance of parsing the trace file.

Here is an example of how to build and execute the tool:

```bash
$ make analyzer
make -C memtrace_analyzer
make[1]: Entering directory `/methodology_for_ArmIE_SVE/sve-tools/memtrace_analyzer'
armclang++ -O3 -mcpu=native -pthread -Iinclude/ -c -o src/analyze.o src/analyze.cpp
armclang++ -O3 -mcpu=native -pthread -Iinclude/ -c -o src/Options.o src/Options.cpp
armclang++ -O3 -mcpu=native -pthread -o bin/analyze src/analyze.o src/Options.o
make[1]: Leaving directory `/methodology_for_ArmIE_SVE/sve-tools/memtrace_analyzer'

$ ./memtrace_analyzer/bin/analyze -t 8 -v 512 -o memtrace_analysis.log merged-memtrace.example.log
########################################
#          SUMMARY                     #
########################################
# VL:                    512 bits
# Memtrace file:         sample/merged-memtrace.example.log
# Output:                stdout
########################################
load/store/total,Total,SVE,non-SVE,SVE-contiguous,SVE-contig-allLanes,SVE-contig-disLanes,SVE-gather/scatter,SVE-gather/scatter-allLanes,SVE-gather/scatter-disLanes
load,13,9,4,6,4,2,3,2,1
store,12,3,9,3,2,1,0,0,0
total,25,12,13,9,6,3,3,2,1
```

The tool parses each trace line and generates a CSV file with statistics regarding memory loads, stores and both (total). It has the following fields:
  * ``Total``: Indicates the total number of memory instructions dynamically executed
  * ``SVE``: Indicates the number of SVE memory instructions dynamically executed
  * ``non-SVE``: Indicates the number of non-SVE memory instructions dynamically executed
  * ``SVE-contiguous``: Indicates the number of SVE memory instructions that accessed contiguous memory addresses
  * ``SVE-contig-allLanes``: Indicates the number of SVE-contiguous instructions where the predicate was set to true in all vector lanes
  * ``SVE-contig-disLanes``: Indicates the number of SVE-contiguous instructions where the predicate was set to false in some lanes
  * ``SVE-gather/scatter``: Indicates the number of SVE gather/scatter memory instructions dynamically executed
  * ``SVE-gather/scatter-allLanes``: Indicates the number of SVE gather/scatter memory instructions where all lanes of the predicate were set to true
  * ``SVE-gather/scatter-disLanes``: Indicates the number of SVE gather/scatter memory instructions where some lanes of the predicate were set to false

## Vector utilization

This tool accepts one merged memory trace and reports the average vector utilization along with the number of accesses for each vector length (in bits). The usage is as follows:

```bash
vec_utilization [OPTIONS] merged_memtrace_file
Options:
        -t <threads>     Specify how many threads to use for parallel processing (default: 1)
        -v <VL>          Vector length (required)
        -o <outputFile>  Redirect output to <outputFile> (default: stdout)
        -h               Print this help
```

```bash
$ make vec_utilization
make -C vec_utilization
make[1]: Entering directory `/methodology_for_ArmIE_SVE/sve-tools/vec_utilization'
armclang++ -O3 -mcpu=native -pthread -Iinclude/ -c -o src/bundle.o src/bundle.cpp
armclang++ -O3 -mcpu=native -pthread -Iinclude/ -c -o src/Options.o src/Options.cpp
armclang++ -O3 -mcpu=native -pthread -o bin/bundle src/bundle.o src/Options.o
make[1]: Leaving directory `/methodology_for_ArmIE_SVE/sve-tools/vec_utilization'

$ ./vec_utilization/bin/vec_utilization -t 8 -v 512 -o memtrace_bundle.log  merged-memtrace.example.log
########################################
#          SUMMARY                     #
########################################
# VL:                    512 bits
# Memtrace file:         ../sample/merged-memtrace.example.log
# Output:                stdout
########################################
VL (bits),#accesses,%accesses
288,4,33.3333
512,8,66.6667

Total SVE Accesses      = 12
Avg. Vector Utilization = 437.3333 bits
Avg. Vector Utilization = 85.4167%
```

The fields reported are:
  * ``VL (bits)``:  Data size (in bits) for the memory access (max size equals the vector length)
  * ``#accesses``:  Number of accesses performed where the number of bits loaded/stored was equal to the VL specified in the first field of the line
  * ``%accesses``: Percentage of accesses above. This percentage is computed as ``#accesses / totalSveAccesses``
  * ``Total SVE Accesses``: Total number of dynamically executed SVE instructions
  * ``Avg. Vector Utilization``: Average number of bits loaded and stored by the SVE memory instructions. One line reports the number in bits, the other as a percentage. The percentage is computed as ``(Avg. Vector Utilization (bits) / Vector Length) * 100``

## FLOPs/Byte

This tool requires a complete instruction and memory trace and reports the average number of floating point operations per byte.

**NOTE**: The instrumentation client to generate a single memory and instruction trace is not yet available in ArmIE (<=19.2) and we cannot provided it here. Merging instruction traces with memory traces is also not possible with the existent instrumentation clients.
We provide this tool as a proof of concept, alongside a sample memory/instruction trace file to serve as a guidance for future studies, when such a client will be made available.

The usage is as follows:
```bash
flops_byte.py [OPTIONS] meminstrace_file veclen
optional arguments:
  -h, --help            show this help message and exit
  -q, --quad            reports quad-precision numbers
  -z, --zipped          processes gzipped traces
```
Note: You need to set `LLVM_MC` before running the tool, in order to decode the instruction trace. 'llvm-mc' is shipped with an LLVM compiler, such as the Arm HPC compiler.

```bash
$ export LLVM_MC=/path/to/arm-hpc-compiler/llvm-bin/llvm-mc

$ python flops_byte.py meminstrace.example_float.log 512

====
 Floating Point Operations per Byte loaded
====

[64 lanes, 1 Bytes ea]
Arithmetic mean = 0.5000
Harmonic mean = 0.5000
[32 lanes, 2 Bytes ea]
Arithmetic mean = 0.2500
Harmonic mean = 0.2500
[16 lanes, 4 Bytes ea]
Arithmetic mean = 0.1250
Harmonic mean = 0.1250
[8 lanes, 8 Bytes ea]
Arithmetic mean = 0.0625
Harmonic mean = 0.0625

====
 FLOP/Byte with update at the end
====

[64 lanes, 1 Bytes ea]
Arithmetic mean = 0.6000
Harmonic mean = 0.5714
[32 lanes, 2 Bytes ea]
Arithmetic mean = 0.3000
Harmonic mean = 0.2857
[16 lanes, 4 Bytes ea]
Arithmetic mean = 0.1500
Harmonic mean = 0.1429
[8 lanes, 8 Bytes ea]
Arithmetic mean = 0.0750
Harmonic mean = 0.0714
```
The tool keeps track of all data loaded into registers and all floating point operations per register. It reports the average FLOPs/Byte (harmonic and arithmetic means) at the end of the trace file and a second time after it, updated with the additional information of the memory accesses and floating point counters that were not flushed at that point.

Due to current limitations in the instrumentation clients, it is not possible to get the number of active SVE lanes from the trace files, but only the relative size of the vector (in bits, rather than in lanes).
As such, the tool admits that all SVE floating operations use the full vector. To this end, it reports the FLOPs/Byte for all possible combinations of number of lanes in the vector, up to a size of 64 bits (8 bytes) per lane. From the output above, a 512-bit SVE execution can thus have between 64 lanes (1 byte each) down to 8 lanes (8 bytes each).
